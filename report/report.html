<!DOCTYPE html>
<html lang="en" >
<head>
    <meta charset="utf-8" />
    <link href="css/main.css" rel="stylesheet" type="text/css" />
    <script type="text/javascript" src="js/script.js"></script>
</head>
<body>
    <div class="example">
        <h1> Raspberry Pi Security Camera Project</h1>
        <h3><a href="index.html"><img src="../images/rindex.png" style="width:60px" onmouseover="this.src='../images/rindex2.png'" onmouseout="this.src='../images/rindex.png'" /></a>
            <a href="../presentation/presentation.html"><img src="../images/rpresentation.png" style="width:60px" onmouseover="this.src='../images/rpresentation2.png'" onmouseout="this.src='../images/rpresentation.png'" /></a>
            <a href="report.html"><img src="../images/rreport.png" style="width:60px" onmouseover="this.src='../images/rreport2.png'" onmouseout="this.src='../images/rreport.png'" /></a>
        </h3>
        <div>
            <h2>Εισαγωγή στο θέμα</h2>
            <p class="report">Η εργασία αποτελείται από δύο παρόμοιες υλοποιήσεις συστήματος παρακολούθησης - κάμερας ασφαλείας, που έχουν ως βάση τον μικρο-υπολογιστή Raspberry Pi. <br><br>
            Σκοπός της εργασίας είναι να παρουσιάσει μία οικονομική αλλά και σύγχρονη εναλλακτική στα συστήματα παρακολούθησης, η οποία είναι ευέλικτη και προσιτή ακόμα και σε άτομα με λιγοστές γνώσεις προγραμματισμού.</p><br>
            <h2>Hardware</h2>
            <p class="report">To Raspberry Pi είναι ένας υπολογιστής μεγέθους πιστωτικής κάρτας που πρωτοεμφανίστηκε στην αγορά το 2012. Εξοπλισμένο μόνο με τα απολύτως απαραίτητα κομμάτια hardware και με CPU των 700MHz (900MHz στο Raspberry Pi Model 2), κατάφερε να σημειώσει πάνω από 5 εκατομμύρια πωλήσεις μέσα σε μόλις τρία χρόνια.<br><br>
            Μέχρι στιγμής έχουν κυκλοφορήσει 5 εκδόσεις του, και η έκδοση που χρησιμοποιήθηκε για την εργασία είναι η B, με τα εξής χαρακτηριστικά:<br></p>
            <ul class="report">
            <li>Chip: Broadcom BCM2835 SoC
			<li>Core architecture: ARM11
			<li>CPU: 700 MHz Low Power ARM1176JZFS Applications Processor
			<li>GPU: Dual Core VideoCore IV® Multimedia Co-Processor (Provides Open GL ES 2.0, hardware-accelerated OpenVG, and 1080p30 H.264 high-profile decode. Capable of 1Gpixel/s, 1.5Gtexel/s or 24GFLOPs with texture filtering and DMA infrastructure.
			<li>Memory: 512MB SDRAM
			<li>Operating System: Boots from Micro SD card, running a version of the Linux operating system
			<li>Dimensions: 85 x 56 x 17mm
			<li>Power: Micro USB socket 5V, 2A</ul><br>
			<p class="report">Επιπλέον, για την καταγραφή βίντεο και τη λήψη φωτογραφιών χρησιμοποιήθηκαν: το "Raspberry Pi Camera Module" και η "USB camera".</p><br>
            <h2>Software</h2>
            <p class="report">Βήμα 1: Αναζήτησα πηγαίο κώδικα που θα μπορεί να χρησιμοποιηθεί ως βάση για την εφαρμογή.<br>
            Βήμα 2: Αναζήτησα πληροφορίες για τα διάφορα φίλτρα που θα μπορούσαν να υλοποιηθούν, παίρνοντας ιδέες από το Gimp. <br>
            Βήμα 3: Βρήκα μία απλή εφαρμογή και μερικούς οδηγούς για φίλτρα μέσω javascript και τα συνδύασα.  *(<a href="http://www.script-tutorials.com/html5-canvas-image-effects-app/">Απλή εφαρμογή</a>, 
                <a href="http://www.html5rocks.com/en/tutorials/canvas/imagefilters/">Οδηγός για φίλτρα</a>)<br>
            Βήμα 4: Φτάνοντας στις 13 λειτουργίες/φίλτρα της εφαρμογής αποφάσισα να βελτιώσω το interface, κάνοντας διάλειμμα από τη javascript και πηγαίνοντας στα css.<br>
            Βήμα 4: Συνέχισα φτιάχνοντας μία απλή παρουσίαση, έχοντας κατά νου να μην ξεπερνάει τα 5 λεπτά, σε συνδυασμό με ένα demo που θα γίνει εκείνη τη στιγμή.<br><br>
            </p>
            <h2>Πώς λειτουργεί</h2>
            <p class="report">Στην κεντρική σελίδα υπάρχουν δύο αντικείμενα canvas - ένα που περιέχει πάντα την αρχική εικόνα και από κάτω του ένα δεύτερο στο οποίο εφαρμόζονται τα φίλτρα.<br>
Αυτό υλοποιήθηκε κατ' αυτόν τον τρόπο, ώστε να δίνεται η δυνατότητα στο χρήστη να παρατηρεί τις διαφορές με την αρχική εικόνα, και να μπορεί να κατεβάσει/αποθηκεύσει την νέα εικόνα.<br>
Επιπλέον, στην κεντρική σελίδα υπάρχουν τα κουμπιά μέσω των οποίων εφαρμόζονται τα φίλτρα.<br><br>
                Τα φίλτρα βρίσκονται σε ένα αρχείο javascript, το οποίο περιλαμβάνει μεθόδους συνδεδεμένες με τα κουμπιά που αναφέρθηκαν προηγουμένως. Συνοπτικά, τα φίλτρα λειτουργούν εξάγοντας τα στοιχεία της εικόνας από κάποιο canvas και αλλάζοντάς τους τις τιμές ως εξής:
            <ul class="report">
                <li>Grayscale: Ορίζονται οι σταθερές p1=0.3, p2=0.59, p3=0.11. Έχουν αυτές τις τιμές λόγω της φύσεω της ανθρώπινης όρασης - που είναι πιο ευαίσθητη στο πράσινο χρώμα. Έπειτα υπολογίζεται η σταθερά grayscale ως το άθροισμα των πολλαπλασιασμών μεταξύ της χρωματικής πληροφορίας κάθε pixel και της αντίστοιχης σταθεράς.</li><br>
            <li>Invert: Αντιστρέφουμε τις χρωματικές πληροφορίες για κάθε pixel αφαιρώντας τες από το 255.</li><br>
            <li>Threshold: Υπολογίζεται η σταθερά threshold ως το άθροισμα των πολλαπλασιασμών μεταξύ της χρωματικής πληροφορίας κάθε pixel και της αντίστοιχης σταθεράς. Οι σταθερές εδώ έχουν τιμές 0.2126 για το κόκκινο, 0.7152 για το πράσινο και 0.0722 για το μπλέ. Πειράζοντας αυτές τις τιμές προκύπτει διαφορετικό αποτέλεσμα, αλλά η εφαρμογή δεν το επιτρέπει - ακόμα.</li><br>
            <li>Sepia: Οι αντίστοιχες σταθερές για το γνωστό sepia effect βρίσκονται διαθέσιμες στο internet. Ουσιαστικά, για κάθε χρωματική πληροφορία του κάθε pixel υπολογίζεται το άθροισμα των χρωματικών πληροφοριών του πολλαπλασιασμένο με διαφορετική σταθερά κάθε φορά.<br>
            data[i]   = (data[i] * 0.393) + (data[i+2] * 0.769) + (data[i+3] * 0.189); // red<br>
            data[i+1] = (data[i] * 0.349) + (data[i+2] * 0.686) + (data[i+3] * 0.168); // green<br>
            data[i+2] = (data[i] * 0.272) + (data[i+2] * 0.534) + (data[i+3] * 0.131); // blue  </li><br>
                <li>Noise: Αρχικά υπολογίζονται τρεις τιμές μέσω της Math.random(). Ύστερα πολλαπλασιάζεται η χρωματική πληροφορία με την αντίστοιχη τιμή και έτσι δημιουργείται το effect ου "θορύβου" πάνω στην εικόνα.</li><br>
                <li>Posterize: Ορίζεται η μεταβλητή valueP=4 και η σταθερά factor ως floor(255/valueP) και έπειτα η χρωματική πληροφορία για κάθε pixel υπολογίζεται ως Math.floor(data[i] / factor) * factor. Αλλάζοντας την τιμή της valueP αλλάζει και  ένταση του φίλτρου, αλλά η εφαρμογή δεν το επιτρέπει - ακόμα.</li><br>
                <li>Horizontal & Vertical Flip: Με τους κατάλληλους μετασχηματισμούς η εικόνα γυρίζει όπως θέλει ο χρήστης.<br>
                Horizontal: translate(imageWidth, 0); scale(-1, 1);<br>
                Vertical: translate(0, imageHeight); scale(1, -1);</li><br>
                <li>Light (+/-): Αλλάζουν οι τιμές φωτεινότητας της εικόνας.</li><br>
                <li>Red/Green/Blue (+/-): Αλλάζει η αντίστοιχη χρωματική τιμή.</li><br>
                <li>Original: Το δεύτερο canvas ξαναζωγραφίζει την εικόνα από το πρώτο canvas.</li><br>
                <li>Blur: Το Blur αποτελεί convolution filter. Αυτό σημαίνει ότι για την εφαρμογή του δεν αρκούν οι χρωματικές πληροφορίες για κάθε pixel, αλλά χρειάζονται και πληροφορίες για τα 8 γειτονικά του. Έτσι, μεταβάλλονται οι τιμές του pixel παρεμβάλλοντας σε αυτό τις τιμές των γειτονικών του. Στο φίλτρο αυτό χρησιμοποιείται και η τέταρτη πληροφορία για κάθε pixel - το opacity.</li><br>
                <li>Saturation: Στο .js έχει αρχικοποιηθεί μεταβλήτη valueS=0. Κάθε φορά που γίνεται κλικ πάνω σε ένα από τα δύο κουμπιά, η μεταβλητή αυτή αυξάνεται ή μειώνεται κατά μία μονάδα και η εικόνα ξαναζωγραφίζεται. Η χρωματική πληροφορία κάθε pixel υπολογίζεται ως data[i]   = avg + value * (data[i] - avg), όπου avg = (data[i] + data[i+1] + data[i+2])/3.</li><br>
                <li>Contrast: Παρομοίως, στο .js υπάρχει μεταβλητή valueC, η τιμή της οποίας αυξομειώνεται με κάθε κλικ. Εδώ υπολογίζεται η τιμή factor = (259 * (valueC + 255)) / (255 * (259 - valueC)) και χρησιμοποιείται ως: data[i] = factor * (data[i] - 128) + 128 (και αντίστοιχα για τις υπόλοιπες 2 τιμές).</li><br><br>
            </ul>
            </p>
        <h2>Οδηγίες χρήσης</h2>
        <p class="report"> ▲ Τα φίλτρα εφαρμόζονται κάνοντας κλικ πάνω σε κάποιο από τα κουμπιά στα αριστερά. Τα κουμπιά ακολουθούν το scrolling για μεγαλύτερη ευχρηστία.<br>
            ▲ Ορισμένα φίλτρα/εφέ (saturation, contrast, light, blur, red/green/blue) επαναφέρουν την εικόνα στην αρχική της κατάσταση πριν εφαρμοστούν. Αυτό οφείλεται στον τρόπο που λειτουργούν. Η "σωστή" υλοποίησή τους είναι κάτι που μπορεί να πραγματοποιηθεί στο μέλλον.<br>
            ▲ Η νέα εικόνα μπορεί να αποθηκευτεί κάνοντας δεξί κλικ πάνω της και ύστερα με την αντίστοιχη επιλογή.<br>
            ▲ Στο About υπάρχουν λίγες διαφάνειες που θα βοηθήσουν στην παρουσίαση. Η πλοήγηση γίνεται με right/left arrow keys.
        </p><br><br>
        </div>
        
    </div>
    <footer class="footer2">
        <p>Created for the purposes of Multimedia Technology Course</p>
        <p>CS AUEB 2014-2015</p>
        <p>Stavropoulos Konstantinos #3100172 -- <a href="mailto:p3100172@dias.aueb.gr">Contact</a></p><br>
    </footer>
</body>
</html>
